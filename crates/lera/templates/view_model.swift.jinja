import Observation

{% for model in models %}
// MARK: {{ model.model_name }}ViewModel

extension {{ model.state_name }} {
	public init() {
		self = {{ model.default_state_fn }}()
	}

	{% if model.enable_samples %}
	public static func samples(n: UInt8) -> [Self] {
		{{ model.samples_state_fn }}(n: n)
	}
	{% endif %}
}

import SwiftUI

extension {{ model.model_name }} {
    public convenience init() {
		let listener = {{ model.model_name }}ViewModel.Listener()
        self.init(
			state: .init(), 
			listener: listener
			{% if model.has_navigator %},
			navigatorListenerOnFfiSide: listener{% endif %}
		)
	}
}

@Observable
@dynamicMemberLookup
public final class {{ model.model_name }}ViewModel: @unchecked Sendable {
	public private(set) var state: {{ model.state_name }}
	@ObservationIgnored
	fileprivate let model: {{ model.model_name }}
	@ObservationIgnored
	private let listener: {{ model.listener_name }}
	@ObservationIgnored
	private let objectId: ObjectIdentifier

		
		{% if model.has_navigator %}
		public typealias Path = [Screen]
		private var _path: Path = []
		public var path: Binding<Path> {
			Binding(
				get: { self._path },
				set: { _ in fatalError("Call setter on `model.navigator` which ATM is unaccessible") }
			)
		}
		{% endif %}
	
	private init(
		model: {{ model.model_name }},
		state: {{ model.state_name }}, 
		listener: Listener
	) {
		self.state = state
		self.listener = listener
		self.model = model
		self.objectId = model.id

		listener.addOnStateChangeForwarder { [weak self] newState in
				print("Swift forwarder got new state")
				self?.state = newState
			}
			{% if model.has_navigator %}
			listener.addNavigationForwarder { path in
				print("Swift navigation path changed: \\(path)")
				self._path = path
			}
		{% endif %}
	}

	public convenience init(model: {{ model.model_name }}) {
		self.init(model: model, state: model.getState(), listener: model.getStateChangeListener() as! Listener)
	}


	private convenience init(
		state: {{ model.state_name }}, 
		listener: Listener
	) {
		self.init(
			model: {{ model.model_name }}(
				state: state,
				listener: listener{% if model.has_navigator %},
				navigatorListenerOnFfiSide: listener{% endif %}
			),
			state: state,
			listener: listener
		)
	}
	
	deinit {
		print("Swift deinit {{ model.model_name }}ViewModel")
	}
	
		public convenience init(
			state: {{ model.state_name }} = {{ model.state_name }}()
		) {
			let listener = Listener()
			self.init(state: state, listener: listener)
		}
	}

extension {{ model.model_name }}: Identifiable {
	public typealias ID = ObjectIdentifier
	public var id: ID { ObjectIdentifier(self) }
}

// MARK: Listener
extension {{ model.model_name }}ViewModel {
	fileprivate final class Listener: {{ model.listener_name }}{% if model.has_navigator %}, ListenerOfNavigationChangesMadeByRust{% endif %}, @unchecked Sendable {

	
		{% if model.has_navigator %}
		typealias OnNavigationChange = @Sendable (Path) -> Void
		private var navigationForwarder: OnNavigationChange?
		{% endif %}

		typealias OnStateChange = @Sendable ({{ model.state_name }}) -> Void
		private var onStateChangeForwarder: OnStateChange?
		init() {}
		
		deinit {
			print("Swift deinit {{ model.model_name }}ViewModel.Listener")
		}
		
		fileprivate func addOnStateChangeForwarder(_ forwarder: @escaping OnStateChange) {
			self.onStateChangeForwarder = forwarder
		}
		
		// MARK: {{ model.listener_name }}
		func onStateChange(state: {{ model.state_name }}) {
			onStateChangeForwarder?(state)
		}
		{% if model.has_navigator %}
		
		// MARK: ListenerOfNavigationChangesMadeByRust
		func pathChangedInRust(path: [Screen]) {
			navigationForwarder?(path)
		}
		
		fileprivate func addNavigationForwarder(_ forwarder: @escaping OnNavigationChange) {
			self.navigationForwarder = forwarder
		}
		{% endif %}
	}
}

// MARK: @dynamicMemberLookup
extension {{ model.model_name }}ViewModel {
	public subscript<Subject>(dynamicMember keyPath: KeyPath<{{ model.state_name }}, Subject>) -> Subject {
		self.state[keyPath: keyPath]
	}
}

// MARK: Forward Actions from view to model (Rust)
extension {{ model.model_name }}ViewModel {
{% for method in model.methods %}
{{ method }}
{% endfor %}
}

extension {{ model.model_name }}ViewModel {
	public typealias State = {{ model.state_name }}
}

{% if model.enable_samples %}
// MARK: Samples
extension {{ model.model_name }}ViewModel {
	/// Creates at most `n` view models using `{{ model.model_name }}State.samples(n:)`.
	public static func samples(n: UInt8) -> [{{ model.model_name }}ViewModel] {
		{{ model.model_name }}ViewModel.State
			.samples(n: n)
			.map({{ model.model_name }}ViewModel.init)
	}
}
{% endif %}

// MARK: Equatable
extension {{ model.model_name }}ViewModel: Equatable {
	// Compare by object identity to ensure stability across state mutations.
	public static func ==(lhs: {{ model.model_name }}ViewModel, rhs: {{ model.model_name }}ViewModel) -> Bool {
		lhs.model === rhs.model
	}
}

// MARK: Hashable
extension {{ model.model_name }}ViewModel: Hashable {
	// Hash by object identity to avoid hash changes when the underlying state mutates.
	public func hash(into hasher: inout Hasher) {
		hasher.combine(objectId)
	}
}

// MARK: Identifiable
extension {{ model.model_name }}ViewModel: Identifiable {
	public var id: ObjectIdentifier { objectId }
}

// MARK: CustomStringConvertible
extension {{ model.model_name }}ViewModel: CustomStringConvertible {
	public var description: String { model.description }
}

// MARK: CustomDebugStringConvertible
extension {{ model.model_name }}ViewModel: CustomDebugStringConvertible {
	public var debugDescription: String { model.debugDescription }
}

{% endfor %}
