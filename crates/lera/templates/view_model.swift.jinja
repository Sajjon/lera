import Observation

{% for model in models %}
// MARK: {{ model.model_name }}ViewModel

extension {{ model.state_name }} {
	public init() {
		self = {{ model.default_state_fn }}()
	}

	{% if model.enable_samples %}
	public static func samples(n: UInt8) -> [Self] {
		{{ model.samples_state_fn }}(n: n)
	}
	{% endif %}
}

@Observable
public final class {{ model.model_name }}ViewModel: @unchecked Sendable {
	
	// MARK: Non-observed properties
	@ObservationIgnored
	fileprivate let model: {{ model.model_name }}
	@ObservationIgnored
	private let listener: {{ model.listener_name }}
	@ObservationIgnored
	private let objectId: ObjectIdentifier

	/// Ignored for observation; use the individual stored properties exposed below.
	/// We let this non observed property be public if we ever want to be able
	/// to grab the whole state e.g. to pass to next viewmodel part of navigation
	/// 
	/// Rust will update this state and we have a `didSet` property observer 
	/// on this property which will update these state properties which **are** observed:
	{%- for field in model.state_fields %}
	///	* ``{{ field.property_name }}``
	{%- endfor %}
	@ObservationIgnored
	public private(set) var state: {{ model.state_name }} {
		didSet {
{% for field in model.state_fields %}
			self.{{ field.property_name }} = state.{{ field.property_name }}
{% endfor %}
		}
	}

	// MARK: Observed Properties
{% for field in model.state_fields %}
    /// Public getter, private setter, this stored property is observed
	/// and gets updated originally from Rust, then here in Swift `state` will
	/// get update which updates this property in its didSet property observer.
	public private(set) var {{ field.property_name }}: {{ field.property_type }}
{% endfor %}

	private init(state: {{ model.state_name }}, listener: {{ model.listener_name }}) {
		self.state = state
		self.listener = listener
		self.model = {{ model.model_name }}(state: state, listener: listener)
		self.objectId = ObjectIdentifier(self.model)
{% for field in model.state_fields %}
		self.{{ field.property_name }} = state.{{ field.property_name }}
{% endfor %}
	}
	
	deinit {
		print("Swift deinit {{ model.model_name }}ViewModel")
	}
	
	public convenience init(state: {{ model.state_name }} = {{ model.state_name }}()) {
		let listener = Listener()
		self.init(state: state, listener: listener)
		listener.add(forwarder: Listener.Forwarder { [weak self] newState in
			print("Swift forwarder got new state")
			self?.state = newState
		})
	}
}

// MARK: Listener
extension {{ model.model_name }}ViewModel {
	fileprivate final class Listener: {{ model.listener_name }}, @unchecked Sendable {

		fileprivate struct Forwarder {
			typealias OnStateChange = @Sendable ({{ model.state_name }}) -> Void
			private let onStateChange: OnStateChange
			init(_ onStateChange: @escaping OnStateChange) {
				self.onStateChange = onStateChange
			}
			fileprivate func forward(_ state: {{ model.state_name }}) {
				self.onStateChange(state)
			}
		}
		
		private var forwarder: Forwarder?
		init() {}
		
		deinit {
			print("Swift deinit {{ model.model_name }}ViewModel.Listener")
		}
		
		fileprivate func add(forwarder: Forwarder) {
			self.forwarder = forwarder
		}
		
		// MARK: {{ model.listener_name }}
		func onStateChange(state: {{ model.state_name }}) {
			forwarder?.forward(state)
		}
	}
}

// MARK: Forward Actions from view to model (Rust)
extension {{ model.model_name }}ViewModel {
{% for method in model.methods %}
{{ method }}
{% endfor %}
}

extension {{ model.model_name }}ViewModel {
	public typealias State = {{ model.state_name }}
}

{% if model.enable_samples %}
// MARK: Samples
extension {{ model.model_name }}ViewModel {
	/// Creates at most `n` view models using `{{ model.model_name }}State.samples(n:)`.
	public static func samples(n: UInt8) -> [{{ model.model_name }}ViewModel] {
		{{ model.model_name }}ViewModel.State
			.samples(n: n)
			.map({{ model.model_name }}ViewModel.init)
	}
}
{% endif %}

// MARK: Equatable
extension {{ model.model_name }}ViewModel: Equatable {
	// Compare by object identity to ensure stability across state mutations.
	public static func ==(lhs: {{ model.model_name }}ViewModel, rhs: {{ model.model_name }}ViewModel) -> Bool {
		lhs.model === rhs.model
	}
}

// MARK: Hashable
extension {{ model.model_name }}ViewModel: Hashable {
	// Hash by object identity to avoid hash changes when the underlying state mutates.
	public func hash(into hasher: inout Hasher) {
		hasher.combine(objectId)
	}
}

// MARK: Identifiable
extension {{ model.model_name }}ViewModel: Identifiable {
	public var id: ObjectIdentifier { objectId }
}

// MARK: CustomStringConvertible
extension {{ model.model_name }}ViewModel: CustomStringConvertible {
	public var description: String { model.description }
}

// MARK: CustomDebugStringConvertible
extension {{ model.model_name }}ViewModel: CustomDebugStringConvertible {
	public var debugDescription: String { model.debugDescription }
}

{% endfor %}
