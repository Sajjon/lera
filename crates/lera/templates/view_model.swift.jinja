import Observation

{% for model in models %}
// MARK: {{ model.model_name }}ViewModel

extension {{ model.state_name }} {
	public init() {
		self = {{ model.default_state_fn }}()
	}

	{% if model.enable_samples %}
	public static func samples(n: UInt8) -> [Self] {
		{{ model.samples_state_fn }}(n: n)
	}
	{% endif %}
}

@Observable
@dynamicMemberLookup
public final class {{ model.model_name }}ViewModel: @unchecked Sendable {
	public private(set) var state: {{ model.state_name }}
	@ObservationIgnored
	fileprivate let model: {{ model.model_name }}
	@ObservationIgnored
	private let listener: {{ model.listener_name }}
	@ObservationIgnored
	private let objectId: ObjectIdentifier
	
	private init(state: {{ model.state_name }}, listener: {{ model.listener_name }}) {
		self.state = state
		self.listener = listener
		self.model = {{ model.model_name }}(state: state, listener: listener)
		self.objectId = ObjectIdentifier(self.model)
	}
	
	deinit {
		log.debug("deinit {{ model.model_name }}ViewModel")
	}
	
	public convenience init(state: {{ model.state_name }} = {{ model.state_name }}()) {
		let listener = Listener()
		self.init(state: state, listener: listener)
		listener.add(forwarder: Listener.Forwarder { [weak self] newState in
			log.trace("forwarder got new state")
			self?.state = newState
		})
	}
}

// MARK: Listener
extension {{ model.model_name }}ViewModel {
	fileprivate final class Listener: {{ model.listener_name }}, @unchecked Sendable {

		fileprivate struct Forwarder {
			typealias OnStateChange = @Sendable ({{ model.state_name }}) -> Void
			private let onStateChange: OnStateChange
			init(_ onStateChange: @escaping OnStateChange) {
				self.onStateChange = onStateChange
			}
			fileprivate func forward(_ state: {{ model.state_name }}) {
				self.onStateChange(state)
			}
		}
		
		private var forwarder: Forwarder?
		init() {}
		
		deinit {
			log.debug("deinit {{ model.model_name }}ViewModel.Listener")
		}
		
		fileprivate func add(forwarder: Forwarder) {
			self.forwarder = forwarder
		}
		
		// MARK: {{ model.listener_name }}
		func onStateChange(state: {{ model.state_name }}) {
			forwarder?.forward(state)
		}
	}
}

// MARK: @dynamicMemberLookup
extension {{ model.model_name }}ViewModel {
	public subscript<Subject>(dynamicMember keyPath: KeyPath<{{ model.state_name }}, Subject>) -> Subject {
		self.state[keyPath: keyPath]
	}
}

// MARK: Forward Actions from view to model (Rust)
extension {{ model.model_name }}ViewModel {
{% for method in model.methods %}
{{ method }}
{% endfor %}
}

extension {{ model.model_name }}ViewModel {
	public typealias State = {{ model.state_name }}
}

{% if model.enable_samples %}
// MARK: Samples
extension {{ model.model_name }}ViewModel {
	/// Creates at most `n` view models using `{{ model.model_name }}State.samples(n:)`.
	public static func samples(n: UInt8) -> [{{ model.model_name }}ViewModel] {
		{{ model.model_name }}ViewModel.State
			.samples(n: n)
			.map({{ model.model_name }}ViewModel.init)
	}
}
{% endif %}

// MARK: Equatable
extension {{ model.model_name }}ViewModel: Equatable {
	// Compare by object identity to ensure stability across state mutations.
	public static func ==(lhs: {{ model.model_name }}ViewModel, rhs: {{ model.model_name }}ViewModel) -> Bool {
		lhs.model === rhs.model
	}
}

// MARK: Hashable
extension {{ model.model_name }}ViewModel: Hashable {
	// Hash by object identity to avoid hash changes when the underlying state mutates.
	public func hash(into hasher: inout Hasher) {
		hasher.combine(objectId)
	}
}

// MARK: Identifiable
extension {{ model.model_name }}ViewModel: Identifiable {
	public var id: ObjectIdentifier { objectId }
}

// MARK: CustomStringConvertible
extension {{ model.model_name }}ViewModel: CustomStringConvertible {
	public var description: String { model.description }
}

// MARK: CustomDebugStringConvertible
extension {{ model.model_name }}ViewModel: CustomDebugStringConvertible {
	public var debugDescription: String { model.debugDescription }
}

{% endfor %}

// MARK: Logging
import OSLog

public var log: Logger {
    Lera.shared.swiftLog
}

fileprivate final class Lera {
    fileprivate let rustLog: Logger = Logger(subsystem: "lera", category: "ü¶Ä Rust")
    fileprivate let swiftLog: Logger = Logger(subsystem: "lera", category: "üê¶‚Äçüî• Swift")
    fileprivate init() {
		installLogger(logger: self)
        #if DEBUG
        rustDiagnosticsLogAtAllLevels()
		swiftDiagnosticsLogAtAllLevels()
        #endif
	}
    
    private func swiftDiagnosticsLogAtAllLevels() {
        swiftLog.trace("Trace")
        swiftLog.debug("Debug")
        swiftLog.info("Info")
        swiftLog.notice("Notice")
        swiftLog.warning("Warn")
        swiftLog.error("Error")
        swiftLog.fault("Fault")
        swiftLog.critical("Critical")
    }
}

extension Lera: FfiLogger {
    func logMessage(message: String, level: FfiLogLevel) {
        switch level {
        case .trace: rustLog.trace("\(message)")
        case .debug: rustLog.debug("\(message)")
        case .info: rustLog.info("\(message)")
        case .warn: rustLog.warning("\(message)")
        case .error: rustLog.error("\(message)")
        }
    }
}

extension Lera {
    static let `shared`: Lera = Lera()
}
