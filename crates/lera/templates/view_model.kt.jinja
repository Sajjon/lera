{% for model in models %}
{% if model.enable_samples %}
fun {{ model.state_name }}.Companion.samples(n: kotlin.UByte): List<{{ model.state_name }}> {
    return {{ model.samples_state_fn }}(n)
}
{% endif %}

class {{ model.model_name }}ViewModel(
    state: {{ model.state_name }} = {{ model.default_state_fn }}()
) : androidx.lifecycle.ViewModel() {

    private val listener = Listener()
    private val model = {{ model.model_name }}(state, listener)
    private val identity: Int = System.identityHashCode(model)
    private val _uiState = kotlinx.coroutines.flow.MutableStateFlow(state)
    val uiState: kotlinx.coroutines.flow.StateFlow<{{ model.state_name }}> =
        _uiState.asStateFlow()

    companion object {
        {% if model.enable_samples %}
        // Samples convenience for ViewModel
        @JvmStatic
        fun samples(n: kotlin.UByte): List<{{ model.model_name }}ViewModel> {
            return {{ model.model_name }}ViewModelState
                .samples(n)
                .map { {{ model.model_name }}ViewModel(it) }
        }
        {% endif %}
    }

    init {
        listener.addForwarder { newState ->
        log.v("forwarder got new state")
            _uiState.value = newState
        }
    }

{% for method in model.methods %}
    {{ method }}

{% endfor %}
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is {{ model.model_name }}ViewModel) return false
        return this.model === other.model
    }

    override fun hashCode(): Int = identity

    override fun toString(): String = model.toString()

    override fun onCleared() {
        super.onCleared()
        listener.clear()
    }

    private inner class Listener : {{ model.listener_name }} {
        private var forwarder: (({{ model.state_name }}) -> Unit)? = null

        fun addForwarder(forwarder: ({{ model.state_name }}) -> Unit) {
            this.forwarder = forwarder
        }

        fun clear() {
            forwarder = null
        }

        override fun onStateChange(state: {{ model.state_name }}) {
            forwarder?.invoke(state)
        }
    }
}

typealias {{ model.model_name }}ViewModelState = {{ model.state_name }}
{% endfor %}

// MARK: Logging
val log: timber.log.Timber.Tree
    get() = Lera.kotlinLog

private object Lera : FfiLogger {
    private const val RUST_LOG_TAG = "ðŸ¦€ Rust"
    private const val KOTLIN_LOG_TAG = "ðŸ¤– Android"

    val kotlinLog: timber.log.Timber.Tree
        get() = timber.log.Timber.tag(KOTLIN_LOG_TAG)

    private val rustLog: timber.log.Timber.Tree
        get() = timber.log.Timber.tag(RUST_LOG_TAG)

    init {
        kotlinDiagnosticsLogAtAllLevels()
        installLogger(this)
        rustDiagnosticsLogAtAllLevels()
    }

    private fun kotlinDiagnosticsLogAtAllLevels() {
        val logger = kotlinLog
        logger.v("Trace")
        logger.d("Debug")
        logger.i("Info")
        logger.w("Warn")
        logger.e("Error")
    }

    override fun logMessage(message: String, level: FfiLogLevel) {
        val logger = rustLog
        when (level) {
            FfiLogLevel.ERROR -> logger.e("%s", message)
            FfiLogLevel.WARN -> logger.w("%s", message)
            FfiLogLevel.INFO -> logger.i("%s", message)
            FfiLogLevel.DEBUG -> logger.d("%s", message)
            FfiLogLevel.TRACE -> logger.v("%s", message)
        }
    }
}
